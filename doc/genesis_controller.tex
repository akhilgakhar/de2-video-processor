\documentclass{capstonedoc}

% Document Info
\title{Sega Genesis Controller Interfacing}
\date{2016-01-23}
\author{Stephen Just}

\usepackage{cite}
\usepackage[hyphens]{url}
\usepackage{graphicx}
\graphicspath{ {images/} }

\begin{document}
\maketitle

%Document body

\section{Introduction}
The Sega Genesis was an old 16-bit game console that was released in North
America in 1989. \cite{SGHistory}

This console features support for two gamepads. Each gamepad has four
directional buttons, a ``Start'' button, and either three or six action
buttons, depending on model of controller. The three-button controller has a
much simpler interface than the six-button controller, making use of a
multiplexer and no other logic to access all of the buttons. This document
focuses only on the three-button Genesis controller. The Genesis controllers
also use a standard DB-9 connector, unlike most other game consoles which
use proprietary connectors.\cite{SGCHwInfo}

\section{Controller Interface}
The Genesis controller uses a female DB-9 connector to interface with a Genesis
console or other device. The pins on this connector are configured as follows:

\vspace{5mm}
\begin{tabular}{ l | l | l }
  Pin & Func (select low) & Func (select high) \\ \hline \hline
  1   & up button         & up button          \\
  2   & down button       & down button        \\
  3   & logic low         & left button        \\
  4   & logic low         & right button       \\
  5   & Power (+5 volts)  & Power (+5 Volts)   \\
  6   & A button          & B button           \\
  7   & select signal     & select signal      \\
  8   & Ground            & Ground             \\
  9   & Start button      & C button           \\
\end{tabular}
\vspace{5mm}

\begin{figure}[t]
  \centering
  \includegraphics[width=6cm]{genesis_controller}
\end{figure}

While the controller was designed for +5 Volts for power, because of its simple
design, it is possible to determine that it is actually capable of 2 - 6 Volts.
This is possible because the controller only contains a single 74HC157
multiplexer chip inside, whose datasheet specifies that the device is operable
within that range, with varying delay times.\cite{TC74HC157AP}

In order to read the buttons on a controller, the master device should apply
a logic high or low to the select pin of the controller, and then query the
state of each of the button pins. Then the master device can switch the state
of the select pin, and then query the values for the other buttons. When a
button is pressed, its value will be logic low. Buttons that are not pressed
will appear as a logic high. Note that reading the up and down buttons of
the controller are not affected by the select signal, as they are connected
directly to the controller plug and not through the multiplexer.

\section{Notes}
On a real Genesis console, the controller's value is read once per video frame,
or 60 times per second. That means that if you are trying to emulate a
controller, the emulated buttons should remain pressed for at least 1/60th of
a second, to ensure that the input is received by the console. Shorter button
presses could be missed entirely.

Be aware that the six-button gamepad has a more complicated interface protocol.
The extra buttons are accessed by toggling the select line on the controller
three times in quick succession. If you want your application to tolerate six-
button controllers, take care not to do this. The six-button controllers should
not go in to this mode if you only toggle the select line once per frame.
This appnote targets the standard three-button genesis controllers and 
corresponding protocol.

\section{Project Setup}
Ensure that you are in possession of a three-button genesis controller, and a 
corresponding adapter board to interface the DB9 connector with the appropriate 
GPIO pins on the DE2. Should an adapter board be unavailable, a 40-pin ribbon 
cable breadboarded with a male DB9 connector according to the pinout described 
in [SCHEMATIC_IMAGE]. 

This tutorial assumes there is a functional system with a VGA_VS signal available 
to act as a clocked source to drive the controller at 60Hz. 

Qsys:
In order to use a genesis controller, a custom component must be created in Qsys.
1. Name the component "genesis"
2. Provide "custom_controller.vhd" as the synthesis file
3. Setup the signals according to the following:
\includegraphics{fig1}
4. Configure the remaining sections as follows:
\includegraphics{fig2}
\includegraphics{fig3}
\includegraphics{fig4}
5. Add the custom component. Connect clock, s0 and reset appropriately.
Ensure that conduit_end is exported properly.
\includegraphics{fig5}

[NEED TO DOUBLE CHECK THIS]
6. Add the 16x2 character display from the university program

7. Regenerate base addresses in the event of conflicts.


Quartus:
The following are required in the toplevel of your quartus entity portmap:

\begin{lstlisting}[language={vhdl},float]
	VGA_VS : buffer std_logic;
	GPIO_0 : inout std_logic_vector (35 downto 0) := (others => 'Z');
\end{lstlisting}

within the architecture portmap:

\begin{lstlisting}[language={vhdl},float]
	video_vga_controller_0_external_interface_VS : out std_logic; -- VS
	genesis_0_conduit_end_vsync  : in    std_logic  := 'X';             -- vsync
	genesis_0_conduit_end_dpad_up_input1            : in    std_logic  := 'X';             -- dpad_up_input1
	genesis_0_conduit_end_dpad_down_input1          : in    std_logic  := 'X';             -- dpad_down_input1
	genesis_0_conduit_end_dpad_left_input1          : in    std_logic  := 'X';             -- dpad_left_input1
	genesis_0_conduit_end_dpad_right_input1         : in    std_logic  := 'X';             -- dpad_right_input1
	genesis_0_conduit_end_select_input1             : out   std_logic;                     -- select_input1
	genesis_0_conduit_end_start_c_input1            : in    std_logic  := 'X';             -- start_c_input1
	genesis_0_conduit_end_ab_input1                 : in    std_logic  := 'X';             -- ab_input1
	genesis_0_conduit_end_dpad_up_input2            : in    std_logic  := 'X';             -- dpad_up_input2
	genesis_0_conduit_end_dpad_down_input2          : in    std_logic  := 'X';             -- dpad_down_input2
	genesis_0_conduit_end_dpad_left_input2          : in    std_logic  := 'X';             -- dpad_left_input2
	genesis_0_conduit_end_dpad_right_input2         : in    std_logic  := 'X';             -- dpad_right_input2
	genesis_0_conduit_end_select_input2             : out   std_logic;                     -- select_input2
	genesis_0_conduit_end_start_c_input2            : in    std_logic  := 'X';             -- start_c_input2
	genesis_0_conduit_end_ab_input2                 : in    std_logic  := 'X';             -- ab_input2
\end{lstlisting}

and within the component portmap:
\begin{lstlisting}[language={vhdl},float]
	video_vga_controller_0_external_interface_VS => VGA_VS,
	genesis_0_conduit_end_vsync  => VGA_VS,
	genesis_0_conduit_end_dpad_up_input1            => GPIO_1(9),            --.dpad_up_input1
	genesis_0_conduit_end_dpad_down_input1          => GPIO_1(13),            --.dpad_down_input1
	genesis_0_conduit_end_dpad_left_input1          => GPIO_1(17),            --.dpad_left_input1
	genesis_0_conduit_end_dpad_right_input1         => GPIO_1(19),            --.dpad_right_input1
	genesis_0_conduit_end_select_input1             => GPIO_1(15),            --.select_input1
	genesis_0_conduit_end_start_c_input1            => GPIO_1(21),            --.start_c_input1
	genesis_0_conduit_end_ab_input1                 => GPIO_1(11),            -- .ab_input1
	genesis_0_conduit_end_dpad_up_input2            => GPIO_1(23),            --.dpad_up_input2
	genesis_0_conduit_end_dpad_down_input2          => GPIO_1(27),            --.dpad_down_input2
	genesis_0_conduit_end_dpad_left_input2          => GPIO_1(31),            --.dpad_left_input2
	genesis_0_conduit_end_dpad_right_input2         => GPIO_1(33),            --.dpad_right_input2
	genesis_0_conduit_end_select_input2             => GPIO_1(29),            --.select_input2
	genesis_0_conduit_end_start_c_input2            => GPIO_1(35),            --.start_c_input2
	genesis_0_conduit_end_ab_input2                 => GPIO_1(25),            --
\end{lstlisting}

Compile the project to ensure its working. 

Eclipse: 
1. Create a new nios II application and BSP from template (HelloWorld/MicroCOS)
2. Replace the contents of the HelloWorld.c with gen_demo.c
3. Running the application on the board will display which button 
is pressed from either controller on the lines of the LCD.

\section{Reading from the Controllers}
The current state for each button for either controller is stored 
in a 32 bit value, with 16 of those bits corresponding to a button 
on either controller. By reading the memory at GENESIS_0_BASE, 
one can examine a particular bit to determine which button is being 
pressed. The code below illustrates this simply: 

\begin{lstlisting}[language={c},float]
	  int genesis_value = IORD_32DIRECT(GENESIS_0_BASE, 0);

	  if ((genesis_value)& (1 << 0)){
		  printf("1 Up was pressed\n");
	  }
	  if ((genesis_value)& (1 << 1)){
		  printf("1 Down was pressed\n");
	  }
	  if ((genesis_value)& (1 << 2)){
		  printf("1 Left was pressed\n");
	  }
	  if ((genesis_value)& (1 << 3)){
		  printf("1 Right was pressed\n");
	  }
	  if ((genesis_value)& (1 << 4)){
		  printf("1 A was pressed\n");
	  }
	  if ((genesis_value)& (1 << 5)){
		  printf("1 B was pressed\n");
	  }
	  if ((genesis_value)& (1 << 6)){
		  printf("1 C was pressed\n");
	  }
	  if ((genesis_value)& (1 << 7)){
		  printf("1 Start was pressed\n");
	  }

	  if ((genesis_value)& (1 << 10)){
		  printf("2 Up was pressed\n");
	  }
	  if ((genesis_value)& (1 << 11)){
		  printf("2 Down was pressed\n");
	  }
	  if ((genesis_value)& (1 << 12)){
		  printf("2 Left was pressed\n");
	  }
	  if ((genesis_value)& (1 << 13)){
		  printf("2 Right was pressed\n");
	  }
	  if ((genesis_value)& (1 << 14)){
		  printf("2 A was pressed\n");
	  }
	  if ((genesis_value)& (1 << 15)){
		  printf("2 B was pressed\n");
	  }
	  if ((genesis_value)& (1 << 16)){
		  printf("2 C was pressed\n");
	  }
	  if ((genesis_value)& (1 << 17)){
		  printf("2 Start was pressed\n");
	  }
\end{lstlisting}

% References
\bibliographystyle{ieeetr}
\bibliography{genesis_controller}

\end{document}
